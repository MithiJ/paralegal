//! Command line arguments and parsing.

use std::borrow::Cow;

/// Top level command line arguments
#[derive(serde::Serialize, serde::Deserialize, clap::Args)]
pub struct Args {
    /// Print additional logging output (up to the "info" level)
    #[clap(short, long, env = "DFPP_VERBOSE")]
    verbose: bool,
    /// Print additional logging output (up to the "debug" level).
    ///
    /// Passing this flag (or env variable) with no value will enable debug
    /// output globally. You may instead pass the name of a specific target
    /// function and then only during analysis of that function the debug output
    /// is enabled.
    #[clap(long, env = "DFPP_DEBUG")]
    debug: bool,
    #[clap(long, env = "DFPP_DEBUG_TARGET")]
    debug_target: Option<String>,
    /// Where to write the resulting forge code to (defaults to `analysis_result.frg`)
    #[clap(long, default_value = "analysis_result.frg")]
    result_path: std::path::PathBuf,
    /// Additional arguments that control the flow analysis specifically
    #[clap(flatten, next_help_heading = "Flow Analysis")]
    anactrl: AnalysisCtrl,
    /// Additional arguments that control the generation and composition of the model
    #[clap(flatten, next_help_heading = "Model Generation")]
    modelctrl: ModelCtrl,
    /// Additional arguments that control debug args specifically
    #[clap(flatten, next_help_heading = "Debugging and Testing")]
    dbg: DbgArgs,
}

/// How a specific logging level was configured. (currently only used for the
/// `--debug` level)
#[derive(Debug, serde::Serialize, serde::Deserialize, Clone)]
pub enum LogLevelConfig<'a> {
    /// Logging for this level is only enabled for a specific target function
    Targeted(Cow<'a, str>),
    /// Logging for this level is not directly enabled
    Disabled,
    /// Logging for this level was directly enabled
    Enabled,
}

impl std::fmt::Display for LogLevelConfig<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{self:?}")
    }
}

impl<'a> LogLevelConfig<'a> {
    pub fn is_enabled(&self) -> bool {
        matches!(self, LogLevelConfig::Targeted(..) | LogLevelConfig::Enabled)
    }
}

impl Args {
    /// Returns the configuration specified for the `--debug` option
    pub fn debug(&self) -> Cow<'_, LogLevelConfig<'_>> {
        Cow::Owned(match &self.debug_target {
            Some(target) if !target.is_empty() => {
                LogLevelConfig::Targeted(Cow::Borrowed(target.as_str()))
            }
            _ if self.debug => LogLevelConfig::Enabled,
            _ => LogLevelConfig::Disabled,
        })
    }
    pub fn dbg(&self) -> &DbgArgs {
        &self.dbg
    }
    pub fn anactrl(&self) -> &AnalysisCtrl {
        &self.anactrl
    }
    pub fn modelctrl(&self) -> &ModelCtrl {
        &self.modelctrl
    }
    pub fn result_path(&self) -> &std::path::Path {
        self.result_path.as_path()
    }
    pub fn verbose(&self) -> bool {
        self.verbose
    }
}

#[derive(serde::Serialize, serde::Deserialize, clap::Args)]
pub struct ModelCtrl {
    /// A JSON file from which to load additional annotations. Whereas normally
    /// annotation can only be placed on crate-local items, these can also be
    /// placed on third party items, such as functions from the stdlib.
    ///
    /// The file is expected to contain a `HashMap<Identifier, (Vec<Annotation>,
    /// ObjectType)>`, which is the same type as `annotations` field from the
    /// `ProgramDescription` struct. It uses the `serde` derived serializer. An
    /// example for the format can be generated by running dfpp with
    /// `dump_serialized_flow_graph`.
    #[clap(long, env)]
    external_annotations: Option<std::path::PathBuf>,
}

impl ModelCtrl {
    pub fn external_annotations(&self) -> Option<&std::path::Path> {
        self.external_annotations.as_ref().map(|p| p.as_path())
    }
}

/// Arguments that control the flow analysis
#[derive(serde::Serialize, serde::Deserialize, clap::Args)]
pub struct AnalysisCtrl {
    /// Disables all recursive analysis (both dfpp's inlining as well as
    /// Flowistry's recursive analysis).
    /// 
    /// Also implies --no-pruning, because pruning only makes sense after inlining
    #[clap(long, env)]
    no_cross_function_analysis: bool,
    #[clap(long, env)]
    no_pruning: bool,
    #[clap(long, env)]
    remove_inconsequential_calls: bool,
}

impl AnalysisCtrl {
    pub fn use_recursive_analysis(&self) -> bool {
        !self.no_cross_function_analysis
    }
    pub fn use_pruning(&self) -> bool {
        !self.no_pruning
    }
    pub fn remove_inconsequential_calls(&self) -> bool {
        self.remove_inconsequential_calls
    }
}

/// Arguments that control the output of debug information or output to be
/// consumed for testing.
#[derive(serde::Serialize, serde::Deserialize, clap::Args)]
pub struct DbgArgs {
    /// Dumps a table representing retrieved Flowistry matrices to stdout.
    #[clap(long, env)]
    dump_flowistry_matrix: bool,
    /// Dumps a dot graph representation of the finely granular, inlined flow of each controller.
    /// Unlike `dump_call_only_flow` this contains also statements and non-call
    /// terminators. It is also created differently (using dependency
    /// resolution) and has not been tested in a while and shouldn't be relied upon.
    #[clap(long, env)]
    dump_inlined_function_flow: bool,
    /// Dumps a dot graph representation of the dataflow between function calls
    /// calculated for each controller to <name of controller>.call-only-flow.gv
    #[clap(long, env)]
    dump_call_only_flow: bool,
    /// Deprecated alias for `dump_call_only_flow`
    #[clap(long, env)]
    dump_non_transitive_graph: bool,
    /// For each controller dumps the calculated dataflow graphs as well as
    /// information about the MIR to <name of controller>.ntgb.json. Can be
    /// deserialized with `crate::dbg::read_non_transitive_graph_and_body`.
    #[clap(long, env)]
    dump_serialized_non_transitive_graph: bool,
    /// Dump a complete `crate::desc::ProgramDescription` in serialized (json)
    /// format to "flow-graph.json". Used for testing.
    #[clap(long, env)]
    dump_serialized_flow_graph: bool,
    /// For each controller dump a dot representation for each [`mir::Body`] as
    /// provided by rustc
    #[clap(long, env)]
    dump_ctrl_mir: bool,
}

impl DbgArgs {
    pub fn dump_ctrl_mir(&self) -> bool {
        self.dump_ctrl_mir
    }
    pub fn dump_serialized_non_transitive_graph(&self) -> bool {
        self.dump_serialized_non_transitive_graph
    }
    pub fn dump_call_only_flow(&self) -> bool {
        self.dump_call_only_flow || self.dump_non_transitive_graph
    }
    pub fn dump_serialized_flow_graph(&self) -> bool {
        self.dump_serialized_flow_graph
    }
}
